<!DOCTYPE html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="../../../../themes/prism.css" rel="stylesheet" />
  <link rel="stylesheet" href="../../../../styles.css" />
  <title>Writing a vector in C</title>
</head>

<body>
  <script src="../../../../scripts/prism.js"></script>

  <header>
    <nav>
      <a href="/">Rasmus KÃ¤llqvist's Blog</a>
      <ul>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/about.html">About</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <h1 class="post-title">Writing a vector in C</h1>
    <time class="post-date" datetime="2023-06-22">June 22 2023</time>
    <article>
      <p>
        This is an article about writing vectors in C99 (aka dynamic arrays).
        We're doing this for the fun of it, to see what can be done with the C
        language, and to get to take a look at
        <a href="https://en.wikipedia.org/wiki/Generic_programming"
          >Generic Programming</a
        >
        in such a simple setting like C provides.
      </p>

      <p>
        We'll implement vectors in C with a combination of preprocessor macros
        and some clever memory layouting, with a trick that I first learnt from
        <a
          href="https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/tests/prerelease/stb_lib.h#L1159"
          >stb.h</a
        >
        by Sean Barrett.
      </p>

      <p>
        You can skip ahead directly to the
        <a href="#implementing-the-vector">vector implementation part</a> of the
        text if you want, as I will start by showing off an example usage of the
        vector and then give some background on generic programming and generic
        types.
      </p>

      <h3>What's a vector?</h3>

      <p>
        A dynamic array is called a Vector in C++ and Rust, and is called an
        ArrayList in Java and C#. In scripting languages like Python and
        JavaScript, all arrays are dynamic, but in C we ordinarily only have
        access to fixed size arrays.
      </p>

      <p>
        Vectors are arrays that can grow and shrink in size as elements are
        added and removed from them, by storing the elements in heap memory and
        re-allocating that memory when needed, instead of storing the items in a
        fixed sized array in stack memory.
      </p>

      <h2>I. Example of using vectors in C</h2>
      <p>
        Let's begin by taking a look at how vectors can be used in a simple C
        program, so we get a sense of the thing we're going to build.
      </p>

      <p>
        This program takes a list of integers as argument on the command line
        and prints their average to stdout. The program consists of three
        functions; <code>parse_numbers</code>, <code>compute_average</code> and
        <code>main</code>.
      </p>

      <p>
        The <code>parse_numbers</code> function takes an array of strings and
        parses them into numbers and pushes them into a newly constructed
        vector, which is then returned to the caller. The
        <code>vec_t(long)</code> type acts like a <code>long[]</code> array, but
        is able to hold any amount of <code>long</code> values (error checking
        omitted for brevity).
      </p>

      <pre><code class="language-c">vec_t(long) parse_numbers(const char* strings[], size_t num_strings) {
    vec_t(long) numbers = vec_new(long);

    for (size_t i = 0; i < num_strings; i++) {
        long number = strtol(strings[i], NULL, 10);
        vec_push(numbers, number);
    }

    return numbers;
}</code></pre>

      <aside class="callout">
        <p>
          <strong>Note:</strong> Already here we can notice that we'll be
          putting preprocessor macros into use. The expressions
          <code>vec_t()</code>, <code>vec_new()</code>, and
          <code>vec_push()</code> will turn out to be macros.
        </p>
      </aside>

      <p>
        Once the input has been parsed, we can take the numbers and compute
        their average with the
        <code>compute_average</code> function, which takes a
        <code>vector</code> as argument and then returns the average as a float.
      </p>

      <p>
        The elements are accessed with the <code>[]</code> bracket operator,
        just like you would an ordinary array, in the expression
        <code>numbers[i]</code>.
      </p>

      <pre><code class="language-c">float compute_average(vec_t(long) numbers) {
    float sum = 0;

    for (size_t i = 0; i < vec_size(numbers); i++) {
        sum += numbers[i];
    }

    return sum / vec_size(numbers);
}</code></pre>

      <p>
        These two functions are then be applied in the
        <code>main</code> function. The user input from stdin is passed into
        <code>parse_numbers</code> (skipping this first argument since that is
        just the executable name), and the average is then computed and printed
        to stdout. Finally, the vector is freed with <code>vec_free()</code>.
      </p>

      <pre><code class="language-c">int main(int argc, char** argv) {
    vec_t(long) numbers = parse_numbers(argc - 1, argv + 1);

    float average = compute_average(numbers);
    printf("%.2f\n", average);

    vec_free(numbers);
    return 0;
}</code></pre>

      <p>Running this program gives the following ouput:</p>

      <pre><code class="language-none">> ./average 14 16 20
16.67
</code></pre>

      <h2>II. Vectors and Generic Programming</h2>
      <p>
        In this section will take a closer look at what's going on with the
        expression <code>vec_t(long)</code>, where the typename
        <code>long</code> appears as argument to another type
        <code>vec_t</code>, and how types like <code>vec_t</code> can be used to
        write re-usable code in a programming style called generic programming.
      </p>

      <h3>Generic types</h3>
      <p>
        When writing C programs, we're used to working with types like
        <code>int</code>, <code>float</code> etc., and enum types and struct
        types. In addition to these we also have <em>pointer types</em> like
        <code>int*</code>, <code>float*</code> and <em>array types</em> like
        <code>int[]</code> and <code>float[]</code>.
      </p>

      <p>
        What's particular about these latter two kinds of types is that we have
        two components:
      </p>

      <ul>
        <li>a type name like <code>int</code> or <code>float</code></li>
        <li>the asterix <code>*</code> or bracket <code>[]</code> suffix</li>
      </ul>

      <p>
        Both pointers and arrays are examples of <em>generic types</em>, meaning
        that we have a type that act like a <em>function</em> from a type to a
        type; they take a type as argument and then return a concrete type back.
        With <code>T</code> as a type parameter, <code>T*</code> stands for a
        generic pointer, and <code>T[]</code> stands for a generic array.
      </p>

      <p>
        The <code>vec_t(long)</code> type we saw in the average example program
        similarly can be split into parts:
      </p>

      <ul>
        <li>the type <code>vec_t</code> itself</li>
        <li>the type argument <code>long</code></li>
      </ul>

      <p>
        Generic types allow us to express <em>collections</em> like vectors,
        hashmaps, trees and sets, that can be written once and then used for any
        type.
      </p>

      <h3>Sorting lists</h3>
      <p>Given that we have collections of things, what can we do with them?</p>

      <p>
        In the scripting language
        <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)"
          >Lisp</a
        >
        , the primary data structure used is a <em>list</em>. The language comes
        with many functions that operate on lists, like sorting and searching,
        that work for <em>any</em>
        lists no matter what items it contains, which allow for those functions
        to be re-used in many different kinds of programs.
      </p>

      <p>
        Lists in Lisp are written e.g.
        <code>'(3 1 2)</code> or <code>'("bob" "charlie" "alice")</code>. These
        lists can then be sorted with the <code>sort</code> function. Both
        <code>#'<</code> and <code>#'string<</code> are less-than-operators, and
        are used as sorting predicates:
      </p>

      <pre><code class="language-lisp">(print (sort '(3 1 2) #'<))
(print (sort '("bob" "charlie" "alice") #'string<))
</code></pre>

      <p>Running the above program gives:</p>
      <pre><code class="language-none">> ./sorting_program
(1 2 3)
("alice" "bob" "charlie")</code></pre>

      <p>
        Both the number list and the string list was sorted using the same
        function, <code>sort</code>.
      </p>

      <h3>Functions operating on generic types</h3>
      <p>
        In a statically typed programming language like C, functions have
        specific types for the parameters and return value. To be able to write
        a function like the Lisp <code>sort</code> function in a statically
        typed language, we need to be able to generalize functions with
        <em>type parameters</em>.
      </p>

      <p>
        Java is a statically typed language that supports generics. The sorting
        function in the Java standard library has the following signature, where
        <code>&lt;T&gt;</code> is the type parameter:
      </p>

      <pre><code class="language-java">void sort(List&lt;T&gt; list)</code></pre>

      <p>A Java program corresponding to the earlier Lisp program would be:</p>

      <pre><code class="language-java">public static void main(String[] args) {
    List&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;(Arrays.asList(2, 3, 1));
    List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(Arrays.asList("Bob", "Charlie", "Alice"));

    Collections.sort(numberList);
    Collections.sort(stringList);

    System.out.println(numberList.toString());
    System.out.println(stringList.toString());
}
</code></pre>

      <p>
        Running this gives:
      </p>

      <pre><code class="language-none">> ./sorting_program
[1, 2, 3]
[Alice, Bob, Charlie]</code></pre>

      <p>
        Whenever we take a specific algorithm, like sorting, and generalize it
        with type parameters, we practice a style of programming called generic
        programming.
      </p>

      <h3>Generics in C using macros</h3>
      <p>((Macros as a kind of C++ templates))</p>

      <h2 id="implementing-the-vector">III. Implementing the Vector</h2>
      <p>(The STB memory layout trick)</p>
      <p>(Writing a concrete vector for int only)</p>
      <p>(Making it generic using macros)</p>
      <p>(Example program using it)</p>

      <h2>IV. Drawbacks</h2>
      <p>(Type alias will give bad compiler error messages)</p>
      <p>(Manual memory management is difficult and error prone)</p>

      <h2>V. Summary</h2>
      <p>(We wrote a Vector as an example of Generic Programming in C)</p>
      <p>(What did we learn?)</p>
    </article>
  </main>

  <footer>
    <p>Â© Rasmus KÃ¤llqvist 2023</p>
  </footer>
</body>
