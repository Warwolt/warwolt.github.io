<!DOCTYPE html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="../../../../themes/prism.css" rel="stylesheet" />
  <link rel="stylesheet" href="../../../../styles.css" />
  <title>Writing a vector in C</title>
</head>

<body>
  <script src="../../../../scripts/prism.js"></script>

  <header>
    <nav>
      <a href="/">Rasmus Källqvist's Blog</a>
      <ul>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/about.html">About</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <h1 class="post-title">Writing a vector in C</h1>
    <time class="post-date" datetime="2023-06-22">June 22 2023</time>
    <article>
      <p>
        This is an article about writing vectors in C99 (aka dynamic arrays).
        We're doing this for the fun of it, to see what can be done with the C
        language, and to get to take a look at
        <a href="https://en.wikipedia.org/wiki/Generic_programming"
          >Generic Programming</a
        >
        in such a simple setting like C provides.
      </p>

      <p>
        We'll implement vectors in C with a combination of preprocessor macros
        and some clever memory layouting, with a trick that I first learnt from
        <a
          href="https://github.com/nothings/stb/blob/5736b15f7ea0ffb08dd38af21067c314d6a3aae9/tests/prerelease/stb_lib.h#L1159"
          >stb.h</a
        >
        by Sean Barrett.
      </p>

      <p>
        You can skip ahead directly to the
        <a href="#implementing-the-vector">vector implementation part</a> of the
        text if you want, as I will start by showing off an example usage of the
        vector and then talk a little about using generic types in C.
      </p>

      <h3>What's a vector?</h3>

      <p>
        A dynamic array is called a Vector in C++ and Rust, and is called an
        ArrayList in Java and C#. In scripting languages like Python and
        JavaScript, all arrays are dynamic, but in C we ordinarily only have
        access to fixed size arrays.
      </p>

      <p>
        Vectors are arrays that can grow and shrink in size as elements are
        added and removed from them, by storing the elements in heap memory and
        re-allocating that memory when needed, instead of storing the items in a
        fixed sized array in stack memory.
      </p>

      <h2>I. Example of using vectors in C</h2>
      <p>
        Let's begin by taking a look at how vectors can be used in a simple C
        program, so we get a sense of the thing we're going to build.
      </p>

      <p>
        This program takes a list of integers as argument on the command line
        and prints their average to stdout. The program consists of three
        functions; <code>parse_numbers</code>, <code>compute_average</code> and
        <code>main</code>.
      </p>

      <p>
        The <code>parse_numbers</code> function takes an array of strings and
        parses them into numbers and pushes them into a newly constructed
        vector, which is then returned to the caller. The
        <code>vec_t(long)</code> type acts like a <code>long[]</code> array, but
        is able to hold any amount of <code>long</code> values (error checking
        omitted for brevity).
      </p>

      <pre><code class="language-c">vec_t(long) parse_numbers(const char* strings[], size_t num_strings) {
    vec_t(long) numbers = vec_new(long);

    for (size_t i = 0; i < num_strings; i++) {
        long number = strtol(strings[i], NULL, 10);
        vec_push(numbers, number);
    }

    return numbers;
}</code></pre>

      <aside class="callout">
        <p>
          <strong>Note:</strong> Already here we can notice that we'll be
          putting preprocessor macros into use. The expressions
          <code>vec_t()</code>, <code>vec_new()</code>, and
          <code>vec_push()</code> will turn out to be macros.
        </p>
      </aside>

      <p>
        Once the input has been parsed, we can take the numbers and compute
        their average with the
        <code>compute_average</code> function, which takes a
        <code>vector</code> as argument and then returns the average as a float.
      </p>

      <p>
        The elements are accessed with the <code>[]</code> bracket operator,
        just like you would an ordinary array, in the expression
        <code>numbers[i]</code>.
      </p>

      <pre><code class="language-c">float compute_average(vec_t(long) numbers) {
    float sum = 0;

    for (size_t i = 0; i < vec_size(numbers); i++) {
        sum += numbers[i];
    }

    return sum / vec_size(numbers);
}</code></pre>

      <p>
        These two functions are then be applied in the
        <code>main</code> function. The user input from stdin is passed into
        <code>parse_numbers</code> (skipping this first argument since that is
        just the executable name), and the average is then computed and printed
        to stdout. Finally, the vector is freed with <code>vec_free()</code>.
      </p>

      <pre><code class="language-c">int main(int argc, char** argv) {
    vec_t(long) numbers = parse_numbers(argc - 1, argv + 1);

    float average = compute_average(numbers);
    printf("%.2f\n", average);

    vec_free(numbers);
    return 0;
}</code></pre>

      <p>Running this program gives the following ouput:</p>

      <pre><code class="language-none">> ./average 14 16 20
16.67
</code></pre>

      <h2>II. Generic types in C</h2>
      <p>
        In this section will take a closer look at what's going on with the
        expression <code>vec_t(long)</code>, where the typename
        <code>long</code> appears as argument to another type
        <code>vec_t</code>, and how we can implement the idea of a "type of
        types" in C.
      </p>

      <h3>Pointers and arrays as built in generic types</h3>
      <p>
        When writing C programs, we're used to working with types like
        <code>int</code>, <code>float</code> etc., and enum types and struct
        types. In addition to these we also have <em>pointer types</em> like
        <code>int*</code>, <code>float*</code> and <em>array types</em> like
        <code>int[]</code> and <code>float[]</code>.
      </p>

      <p>
        What's particular about these latter two kinds of types is that we have
        two components:
      </p>

      <ul>
        <li>a type name like <code>int</code> or <code>float</code></li>
        <li>the asterix <code>*</code> or bracket <code>[]</code> suffix</li>
      </ul>

      <p>
        Both pointers and arrays are examples of <em>generic types</em>, meaning
        that we have a type that act like a <em>function</em> from a type to a
        type; they take a type as argument and then return a concrete type back.
      </p>

      <p>With <code>T</code> as a type parameter, we have that:</p>
      <ul>
        <li><code>T*</code> is the generic type of all pointers</li>
        <li><code>T[]</code> is the generic type of all arrays</li>
      </ul>

      <p>
        As we can see, there is some limited support for generic types in just
        plain C. Later in this section we'll see how we can also emulate
        <em>user defined</em> generic types.
      </p>

      <h3>Generic sorting function in C</h3>
      <p>
        Given that we have a generic type of arrays <code>T[]</code>, are we
        able to write functions on that type? In languages like C++, Java, C#
        and Haskell, it's possible to write functions that accept generic types
        as arguments.
      </p>

      <p>
        As an example, if you want to sort a list in Java, you can use the
        <code>void Collections.sort(List&lt;T&gt; list>)</code> function, where
        <code>T</code> is a type parameter passed to the <code>List</code> type:
      </p>

      (JAVA EXAMPLE)

      <p>
        The C language does not directly support writing these kinds of
        functions. It is however still possible to emulate them, and the C
        standard library does come with a generic sorting function:
      </p>

      <pre><code class="language-c">// stdlib.h
void qsort(
  void* base,
  size_t number,
  size_t width,
  int (__cdecl *compare )(const void *, const void *)
);</code></pre>

      <p>What's going on here? There's no type parameter</p>

      <h3>Implementing generic types in C</h3>
      <p>((Treating all types as sequences of bytes + using macros))</p>

      <h2 id="implementing-the-vector">III. Implementing the Vector</h2>
      <p>(The STB memory layout trick)</p>
      <p>(Writing a concrete vector for int only)</p>
      <p>(Making it generic using macros)</p>
      <p>(Example program using it)</p>

      <h2>IV. Drawbacks</h2>
      <p>(Type alias will give bad compiler error messages)</p>
      <p>(Manual memory management is difficult and error prone)</p>

      <h2>V. Summary</h2>
      <p>(We wrote a Vector as an example of Generic Programming in C)</p>
      <p>(What did we learn?)</p>
    </article>
  </main>

  <footer>
    <p>© Rasmus Källqvist 2023</p>
  </footer>
</body>
